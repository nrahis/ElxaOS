<!DOCTYPE html>
<html>
<head>
    <title>Abbit - The Front Page of Snakesia</title>
    <link rel="stylesheet" href="./assets/interwebs/abbit/styles.css">
</head>
<body>
    <div class="ab-container">
        <!-- Header -->
        <header class="ab-header">
            <div class="ab-header-content">
                <div class="ab-logo">
                    <span class="ab-logo-icon">üêç</span>
                    <span class="ab-logo-text">abbit</span>
                </div>
                <div class="ab-search-bar">
                    <input type="text" placeholder="Search Abbit..." class="ab-search-input">
                </div>
                <div class="ab-user-menu">
                    <div class="ab-user-info">
                        <span class="ab-username">You</span>
                        <span class="ab-karma">üë§ 1 karma</span>
                    </div>
                </div>
            </div>
        </header>

        <div class="ab-main-content">
            <!-- Sidebar -->
            <aside class="ab-sidebar">
                <div class="ab-subbabbit-list">
                    <div class="ab-sidebar-section">
                        <h3>Popular Communities</h3>
                        <div id="subrabbitsList">
                            <!-- Subbabbits will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Main Feed -->
            <main class="ab-feed">
                <div class="ab-feed-header">
                    <h2 id="feedTitle">Popular Posts</h2>
                    <div class="ab-sort-controls">
                        <select id="sortSelect" class="ab-sort-select">
                            <option value="hot">üî• Hot</option>
                            <option value="new">üÜï New</option>
                            <option value="top">‚≠ê Top</option>
                        </select>
                    </div>
                </div>

                <div id="postsList" class="ab-posts-list">
                    <div class="ab-loading">Loading posts...</div>
                </div>
            </main>
        </div>

        <!-- Post Modal -->
        <div id="postModal" class="ab-modal" style="display: none;">
            <div class="ab-modal-content">
                <div class="ab-modal-header">
                    <button id="closeModal" class="ab-close-button">√ó</button>
                </div>
                <div id="modalContent" class="ab-modal-body">
                    <!-- Post details and comments will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('üêç Abbit: JavaScript loaded');
        
        class AbbitApp {
            constructor() {
                console.log('üêç Abbit: Constructor starting...');
                
                this.currentSubbabbit = 'all';
                this.currentSort = 'hot';
                this.posts = [];
                this.allPosts = [];
                this.postComments = {}; // Store comments per post
                this.maxComments = 50; // Limit comments per post
                this.llmService = null;
                this.currentPostId = null;
                
                console.log('üêç Abbit: Basic properties set');
                
                // Initialize asynchronously
                this.initialize();
            }

            async initialize() {
                try {
                    await this.initializeData();
                    console.log('üêç Abbit: Data initialized');
                    
                    this.setupEventListeners();
                    console.log('üêç Abbit: Event listeners set up');
                    
                    this.loadSubbabbits();
                    console.log('üêç Abbit: Subbabbits loaded');
                    
                    this.generateInitialPosts();
                    console.log('üêç Abbit: Posts generated');
                    
                    this.displayPosts();
                    console.log('üêç Abbit: Posts displayed');
                    
                } catch (error) {
                    console.error('‚ùå Abbit: Initialization error:', error);
                    
                    // Show error message to user
                    const postsList = document.getElementById('postsList');
                    if (postsList) {
                        postsList.innerHTML = `
                            <div class="ab-loading" style="color: #ff4444;">
                                ‚ùå Failed to load Abbit data: ${error.message}
                                <br><br>
                                Please make sure the abbit-data.json file exists in the correct location.
                            </div>
                        `;
                    }
                }
            }

            async initializeData() {
                console.log('üêç Loading data from abbit-data.json...');
                
                try {
                    // Use fallback data if file not found
                    const data = await this.loadDataFile();
                    
                    // Set properties from loaded data
                    this.subbabbits = data.subbabbits;
                    this.postTemplates = data.postTemplates;
                    this.postVariables = data.postVariables;
                    this.users = data.users;
                    
                    console.log('‚úÖ Data loaded successfully');
                    
                } catch (error) {
                    console.error('‚ùå Failed to load data, using fallback:', error);
                    this.initializeFallbackData();
                }
            }

            initializeFallbackData() {
                // Fallback data structure for testing
                this.subbabbits = {
                    'snakesia': {
                        name: 'r/Snakesia',
                        icon: 'üêç',
                        color: '#FF4500',
                        description: 'All about life in Snakesia',
                        members: '15.2k'
                    },
                    'elxacorp': {
                        name: 'r/ElxaCorp',
                        icon: 'üè¢',
                        color: '#0066CC',
                        description: 'ElxaCorp news and updates',
                        members: '8.3k'
                    },
                    'gaming': {
                        name: 'r/Gaming',
                        icon: 'üéÆ',
                        color: '#9146FF',
                        description: 'Gaming discussions',
                        members: '12.1k'
                    }
                };

                this.users = {
                    'You': { avatar: 'üë§', karma: 1, name: 'You' },
                    'RemiMarway': { avatar: 'üòé', karma: 2847, name: 'Remi Marway' },
                    'Snake_E_CEO': { avatar: 'üêç', karma: 9999, name: 'Mr. Snake-e' },
                    'Mrs_Snake_E': { avatar: 'üëµ', karma: 1234, name: 'Mrs. Snake-e' },
                    'PushingCat': { avatar: 'üê±', karma: 666, name: 'Pushing Cat' }
                };

                this.postTemplates = {
                    'snakesia': [{
                        title: 'Just moved to Snakesia, any tips?',
                        content: 'New resident here! What should I know about living in Snakesia?',
                        author: 'RemiMarway',
                        type: 'text',
                        weight: 5,
                        votes: { min: 15, max: 100 },
                        comments: { min: 5, max: 25 }
                    }],
                    'elxacorp': [{
                        title: 'ElxaOS update is amazing!',
                        content: 'The new features in the latest ElxaOS update are incredible. Great work team!',
                        author: 'Snake_E_CEO',
                        type: 'text',
                        weight: 5,
                        votes: { min: 25, max: 150 },
                        comments: { min: 8, max: 30 }
                    }]
                };

                this.postVariables = {};
            }

            async loadDataFile() {
                const possiblePaths = [
                    'abbit-data.json',
                    './assets/interwebs/abbit/abbit-data.json',
                    './abbit-data.json',
                    'assets/interwebs/abbit/abbit-data.json'
                ];
                
                // Try file system API first
                if (window.fs && window.fs.readFile) {
                    for (const path of possiblePaths.slice(0, 2)) {
                        try {
                            const fileData = await window.fs.readFile(path, { encoding: 'utf8' });
                            return JSON.parse(fileData);
                        } catch (error) {
                            continue;
                        }
                    }
                }
                
                // Fallback to fetch API
                for (const path of possiblePaths.slice(2)) {
                    try {
                        const response = await fetch(path);
                        if (response.ok) {
                            return await response.json();
                        }
                    } catch (error) {
                        continue;
                    }
                }
                
                throw new Error('Could not find abbit-data.json');
            }

            setupEventListeners() {
                console.log('üêç Setting up event listeners...');
                
                // Sort selection
                document.getElementById('sortSelect').addEventListener('change', (e) => {
                    this.currentSort = e.target.value;
                    console.log('üêç Sort changed to:', this.currentSort);
                    this.displayPosts();
                });

                // Modal close
                document.getElementById('closeModal').addEventListener('click', () => {
                    this.closeModal();
                });

                // Click outside modal to close
                document.getElementById('postModal').addEventListener('click', (e) => {
                    if (e.target.id === 'postModal') {
                        this.closeModal();
                    }
                });

                // Search functionality
                document.querySelector('.ab-search-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const query = e.target.value.trim();
                        if (query) {
                            this.searchPosts(query);
                        }
                    }
                });

                // Event delegation for modal content (fixes comment voting issue)
                document.getElementById('modalContent').addEventListener('click', (e) => {
                    this.handleModalClick(e);
                });
                
                console.log('‚úÖ Event listeners setup complete');
            }

            // NEW: Handle all modal clicks with event delegation
            handleModalClick(e) {
                const target = e.target;
                
                // Comment voting
                if (target.classList.contains('ab-comment-vote')) {
                    e.stopPropagation();
                    e.preventDefault();
                    const commentId = target.dataset.commentId;
                    const isUpvote = target.classList.contains('ab-comment-upvote');
                    console.log('üêç Comment vote clicked:', commentId, isUpvote ? 'up' : 'down');
                    this.voteComment(this.currentPostId, commentId, isUpvote ? 'up' : 'down');
                }
                
                // Reply buttons
                else if (target.classList.contains('ab-reply-button')) {
                    const commentId = target.dataset.commentId;
                    this.showReplyInput(commentId);
                }
                
                // Reply submit
                else if (target.classList.contains('ab-reply-submit')) {
                    const commentId = target.dataset.commentId;
                    this.submitReply(this.currentPostId, commentId);
                }
                
                // Reply cancel
                else if (target.classList.contains('ab-reply-cancel')) {
                    const commentId = target.dataset.commentId;
                    this.hideReplyInput(commentId);
                }
                
                // Comment submission
                else if (target.id === 'postComment') {
                    this.submitComment(this.currentPostId);
                }
            }

            loadSubbabbits() {
                const subrabbitsList = document.getElementById('subrabbitsList');
                
                let html = `
                    <div class="ab-subbabbit-item ${this.currentSubbabbit === 'all' ? 'active' : ''}" 
                         data-subbabbit="all">
                        <span class="ab-subbabbit-icon">üè†</span>
                        <span class="ab-subbabbit-name">All</span>
                    </div>
                `;
                
                Object.entries(this.subbabbits).forEach(([id, subbabbit]) => {
                    const isActive = this.currentSubbabbit === id ? 'active' : '';
                    html += `
                        <div class="ab-subbabbit-item ${isActive}" data-subbabbit="${id}">
                            <span class="ab-subbabbit-icon">${subbabbit.icon}</span>
                            <div class="ab-subbabbit-info">
                                <span class="ab-subbabbit-name">${subbabbit.name}</span>
                                <span class="ab-subbabbit-members">${subbabbit.members} members</span>
                            </div>
                        </div>
                    `;
                });
                
                subrabbitsList.innerHTML = html;
                
                // Add click listeners
                document.querySelectorAll('.ab-subbabbit-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const subrabbittId = e.target.closest('.ab-subbabbit-item').dataset.subbabbit;
                        this.loadSubbabbit(subrabbittId);
                    });
                });
            }

            loadSubbabbit(subrabbittId) {
                console.log('üêç Loading subbabbit:', subrabbittId);
                
                this.currentSubbabbit = subrabbittId;
                
                // Update active state
                document.querySelectorAll('.ab-subbabbit-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelector(`[data-subbabbit="${subrabbittId}"]`).classList.add('active');
                
                // Update feed title
                const feedTitle = document.getElementById('feedTitle');
                if (subrabbittId === 'all') {
                    feedTitle.textContent = 'Popular Posts';
                } else {
                    feedTitle.textContent = this.subbabbits[subrabbittId].name;
                }
                
                this.displayPosts();
            }

            generateInitialPosts() {
                console.log('üêç Generating initial posts...');
                
                this.allPosts = [];
                const totalPosts = 15;
                
                // Generate sample posts
                for (let i = 0; i < totalPosts; i++) {
                    const subrabbits = Object.keys(this.subbabbits);
                    const randomSub = subrabbits[Math.floor(Math.random() * subrabbits.length)];
                    const post = this.createSamplePost(randomSub, i);
                    if (post) {
                        this.allPosts.push(post);
                    }
                }
                
                // Sort by timestamp (newest first)
                this.allPosts.sort((a, b) => b.timestamp - a.timestamp);
                
                console.log(`‚úÖ Generated ${this.allPosts.length} posts`);
            }

            createSamplePost(subrabbittId, index) {
                const subbabbit = this.subbabbits[subrabbittId];
                const userIds = Object.keys(this.users).filter(u => u !== 'You');
                const author = userIds[Math.floor(Math.random() * userIds.length)];
                const user = this.users[author];
                
                const sampleTitles = [
                    'Just discovered this amazing place in Snakesia!',
                    'ElxaOS update coming soon - what features do you want?',
                    'Gaming setup complete! Rate my build',
                    'Mrs. Snake-e shared her famous recipe',
                    'Pushing Cat got into trouble again...',
                    'Remi\'s new YouTube video is incredible!',
                    'Weather in Snakesia is perfect today',
                    'New business opening in downtown Snakesia'
                ];
                
                const sampleContent = [
                    'This is really worth checking out if you\'re in the area!',
                    'Let me know what you think in the comments.',
                    'Been working on this for weeks, finally ready to share.',
                    'The community here is amazing.',
                    'Hope this helps someone!',
                    'What are your thoughts on this?'
                ];
                
                const hoursAgo = Math.random() * 24;
                const timestamp = new Date(Date.now() - hoursAgo * 60 * 60 * 1000);
                
                return {
                    id: Date.now() + Math.random() + index,
                    subbabbit: subrabbittId,
                    title: sampleTitles[index % sampleTitles.length],
                    content: sampleContent[Math.floor(Math.random() * sampleContent.length)],
                    author: author,
                    user: user,
                    type: 'text',
                    votes: Math.floor(Math.random() * 100) + 5,
                    commentCount: Math.floor(Math.random() * 15) + 2,
                    timestamp: timestamp,
                    upvoted: false,
                    downvoted: false
                };
            }

            displayPosts() {
                let postsToShow = [...this.allPosts];
                
                // Filter by subbabbit
                if (this.currentSubbabbit !== 'all') {
                    postsToShow = postsToShow.filter(post => post.subbabbit === this.currentSubbabbit);
                }
                
                // Sort posts
                switch (this.currentSort) {
                    case 'new':
                        postsToShow.sort((a, b) => b.timestamp - a.timestamp);
                        break;
                    case 'top':
                        postsToShow.sort((a, b) => b.votes - a.votes);
                        break;
                    case 'hot':
                    default:
                        // Hot algorithm: combination of votes and recency
                        postsToShow.sort((a, b) => {
                            const aScore = a.votes * Math.pow(0.8, (Date.now() - a.timestamp) / (1000 * 60 * 60));
                            const bScore = b.votes * Math.pow(0.8, (Date.now() - b.timestamp) / (1000 * 60 * 60));
                            return bScore - aScore;
                        });
                        break;
                }
                
                this.posts = postsToShow;
                this.renderPosts();
            }

            renderPosts() {
                const postsList = document.getElementById('postsList');
                
                if (this.posts.length === 0) {
                    postsList.innerHTML = '<div class="ab-loading">No posts found</div>';
                    return;
                }
                
                const html = this.posts.map(post => this.renderPostCard(post)).join('');
                postsList.innerHTML = html;
                
                // Add event listeners for posts
                this.posts.forEach(post => {
                    const postElement = document.querySelector(`[data-post-id="${post.id}"]`);
                    if (postElement) {
                        const postContent = postElement.querySelector('.ab-post-content');
                        if (postContent) {
                            postContent.addEventListener('click', (e) => {
                                this.openPostModal(post);
                            });
                            postContent.style.cursor = 'pointer';
                        }
                    }
                    
                    // Post vote buttons
                    const postCard = document.querySelector(`[data-post-id="${post.id}"]`);
                    if (postCard) {
                        const upvoteBtn = postCard.querySelector('.ab-upvote');
                        const downvoteBtn = postCard.querySelector('.ab-downvote');
                        
                        if (upvoteBtn) {
                            upvoteBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                this.votePost(post.id, 'up');
                            });
                        }
                        
                        if (downvoteBtn) {
                            downvoteBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                this.votePost(post.id, 'down');
                            });
                        }
                    }
                });
            }

            renderPostCard(post) {
                const subbabbit = this.subbabbits[post.subbabbit];
                const timeAgo = this.formatTimeAgo(post.timestamp);
                
                return `
                    <article class="ab-post-card" data-post-id="${post.id}">
                        <div class="ab-post-votes">
                            <button class="ab-vote-button ab-upvote ${post.upvoted ? 'voted' : ''}">
                                ‚¨ÜÔ∏è
                            </button>
                            <span class="ab-vote-count">${post.votes}</span>
                            <button class="ab-vote-button ab-downvote ${post.downvoted ? 'voted' : ''}">
                                ‚¨áÔ∏è
                            </button>
                        </div>
                        <div class="ab-post-content">
                            <div class="ab-post-header">
                                <span class="ab-subbabbit-link" style="color: ${subbabbit.color}">
                                    ${subbabbit.icon} ${subbabbit.name}
                                </span>
                                <span class="ab-post-meta">
                                    ‚Ä¢ Posted by ${post.user.avatar} u/${post.author} ‚Ä¢ ${timeAgo}
                                </span>
                            </div>
                            <h3 class="ab-post-title">${post.title}</h3>
                            <div class="ab-post-body">${post.content}</div>
                            <div class="ab-post-footer">
                                <span class="ab-comment-count">üí¨ ${post.commentCount} comments</span>
                                <span class="ab-share-button">üîó Share</span>
                            </div>
                        </div>
                    </article>
                `;
            }

            formatTimeAgo(timestamp) {
                const now = new Date();
                const diff = now - timestamp;
                
                if (diff < 60000) {
                    return 'just now';
                } else if (diff < 3600000) {
                    const minutes = Math.floor(diff / 60000);
                    return `${minutes}m ago`;
                } else if (diff < 86400000) {
                    const hours = Math.floor(diff / 3600000);
                    return `${hours}h ago`;
                } else {
                    const days = Math.floor(diff / 86400000);
                    return `${days}d ago`;
                }
            }

            votePost(postId, direction) {
                const post = this.allPosts.find(p => p.id === postId);
                if (!post) return;
                
                console.log(`üêç Voting ${direction} on post:`, post.title);
                
                if (direction === 'up') {
                    if (post.upvoted) {
                        post.upvoted = false;
                        post.votes--;
                    } else {
                        if (post.downvoted) {
                            post.downvoted = false;
                            post.votes++;
                        }
                        post.upvoted = true;
                        post.votes++;
                    }
                } else if (direction === 'down') {
                    if (post.downvoted) {
                        post.downvoted = false;
                        post.votes++;
                    } else {
                        if (post.upvoted) {
                            post.upvoted = false;
                            post.votes--;
                        }
                        post.downvoted = true;
                        post.votes--;
                    }
                }
                
                this.displayPosts();
            }

            openPostModal(post) {
                console.log('üêç Opening post modal:', post.title);
                
                this.currentPostId = post.id;
                const modal = document.getElementById('postModal');
                const modalContent = document.getElementById('modalContent');
                
                // Generate post comments if they don't exist
                if (!this.postComments[post.id]) {
                    this.generatePostComments(post);
                }
                
                const comments = this.postComments[post.id] || [];
                console.log('üêç Rendering modal with', comments.length, 'top-level comments');
                
                // Debug: Log comment structure
                comments.forEach((comment, index) => {
                    console.log(`Comment ${index}:`, comment.content, 'Replies:', comment.replies ? comment.replies.length : 0);
                    if (comment.replies && comment.replies.length > 0) {
                        comment.replies.forEach((reply, replyIndex) => {
                            console.log(`  Reply ${replyIndex}:`, reply.content, 'Author:', reply.author);
                        });
                    }
                });
                
                const subbabbit = this.subbabbits[post.subbabbit];
                
                modalContent.innerHTML = `
                    <div class="ab-modal-post">
                        <div class="ab-modal-post-header">
                            <span class="ab-subbabbit-link" style="color: ${subbabbit.color}">
                                ${subbabbit.icon} ${subbabbit.name}
                            </span>
                            <span class="ab-post-meta">
                                ‚Ä¢ Posted by ${post.user.avatar} u/${post.author} ‚Ä¢ ${this.formatTimeAgo(post.timestamp)}
                            </span>
                        </div>
                        <h2 class="ab-modal-post-title">${post.title}</h2>
                        <div class="ab-modal-post-content">${post.content}</div>
                        <div class="ab-modal-post-stats">
                            <span class="ab-vote-info">üëç ${post.votes} votes</span>
                            <span class="ab-comment-info">üí¨ ${this.getTotalCommentCount(comments)} comments</span>
                        </div>
                    </div>
                    
                    <div class="ab-comment-section">
                        <div class="ab-comment-input-section">
                            <textarea 
                                id="commentInput" 
                                class="ab-comment-input" 
                                placeholder="What are your thoughts?"
                                rows="3"
                            ></textarea>
                            <button id="postComment" class="ab-comment-submit">Comment</button>
                        </div>
                        
                        <div class="ab-comments-list">
                            ${comments.map(comment => this.renderComment(comment)).join('')}
                        </div>
                    </div>
                `;
                
                modal.style.display = 'flex';
                
                // Add enter key support for comment input
                document.getElementById('commentInput').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        this.submitComment(post.id);
                    }
                });
            }

            generatePostComments(post) {
                console.log('üêç Generating comments for post:', post.title);
                
                const commentCount = Math.floor(Math.random() * 6) + 2; // 2-7 comments
                const comments = [];
                
                const allUsers = Object.keys(this.users).filter(user => user !== 'You');
                const availableUsers = [...allUsers];
                
                const commentTexts = [
                    "This is really interesting!",
                    "Great post, thanks for sharing!",
                    "I had a similar experience",
                    "Thanks for the info!",
                    "Very helpful, appreciate it",
                    "Love seeing content like this",
                    "This is exactly what I needed",
                    "Couldn't agree more",
                    "Well said!",
                    "This made my day"
                ];
                
                for (let i = 0; i < Math.min(commentCount, availableUsers.length); i++) {
                    const randomIndex = Math.floor(Math.random() * availableUsers.length);
                    const randomUser = availableUsers[randomIndex];
                    const user = this.users[randomUser];
                    
                    availableUsers.splice(randomIndex, 1);
                    
                    const comment = {
                        id: Date.now() + Math.random() + i,
                        author: randomUser,
                        user: user,
                        content: commentTexts[Math.floor(Math.random() * commentTexts.length)],
                        votes: Math.floor(Math.random() * 20) + 1,
                        timestamp: new Date(post.timestamp.getTime() + Math.random() * 3600000),
                        type: 'generated',
                        parentId: null,
                        replies: []
                    };
                    
                    comments.push(comment);
                }
                
                comments.sort((a, b) => a.timestamp - b.timestamp);
                this.postComments[post.id] = comments;
                console.log(`‚úÖ Generated ${comments.length} comments for post`);
            }

            renderComment(comment, depth = 0) {
                const marginLeft = depth * 24;
                const repliesHtml = comment.replies && comment.replies.length > 0 
                    ? comment.replies.map(reply => this.renderComment(reply, depth + 1)).join('')
                    : '';
                
                return `
                    <div class="ab-comment-thread" style="margin-left: ${marginLeft}px;">
                        <div class="ab-comment" data-comment-id="${comment.id}">
                            <div class="ab-comment-votes">
                                <button class="ab-comment-vote ab-comment-upvote" data-comment-id="${comment.id}">‚¨ÜÔ∏è</button>
                                <span class="ab-comment-vote-count">${comment.votes}</span>
                                <button class="ab-comment-vote ab-comment-downvote" data-comment-id="${comment.id}">‚¨áÔ∏è</button>
                            </div>
                            <div class="ab-comment-content">
                                <div class="ab-comment-header">
                                    ${comment.user.avatar} <strong>u/${comment.author}</strong>
                                    <span class="ab-comment-time">${this.formatTimeAgo(comment.timestamp)}</span>
                                    ${comment.type === 'user' ? '<span class="ab-user-badge">YOU</span>' : ''}
                                    ${comment.type === 'llm' ? '<span class="ab-llm-badge">üí¨</span>' : ''}
                                </div>
                                <div class="ab-comment-body">${comment.content}</div>
                                <div class="ab-comment-actions">
                                    <button class="ab-reply-button" data-comment-id="${comment.id}">‚Ü©Ô∏è Reply</button>
                                </div>
                                <div class="ab-reply-input" id="replyInput-${comment.id}" style="display: none;">
                                    <textarea class="ab-reply-textarea" placeholder="Write a reply..." rows="2"></textarea>
                                    <div class="ab-reply-buttons">
                                        <button class="ab-reply-submit" data-comment-id="${comment.id}">Reply</button>
                                        <button class="ab-reply-cancel" data-comment-id="${comment.id}">Cancel</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        ${repliesHtml}
                    </div>
                `;
            }

            async submitComment(postId) {
                const commentInput = document.getElementById('commentInput');
                const content = commentInput.value.trim();
                
                if (!content) return;
                
                console.log('üêç Submitting comment:', content);
                
                const userComment = {
                    id: Date.now() + Math.random(),
                    author: 'You',
                    user: { avatar: 'üë§', karma: 1, name: 'You' },
                    content: content,
                    votes: 1,
                    timestamp: new Date(),
                    type: 'user',
                    parentId: null,
                    replies: []
                };
                
                if (!this.postComments[postId]) {
                    this.postComments[postId] = [];
                }
                this.postComments[postId].push(userComment);
                
                const post = this.allPosts.find(p => p.id === postId);
                if (post) {
                    post.commentCount++;
                }
                
                commentInput.value = '';
                this.openPostModal(post);
                
                // FIXED: Generate LLM response as reply to user's comment
                setTimeout(() => {
                    this.generateLLMCommentReply(postId, userComment.id, content);
                }, 1000 + Math.random() * 3000);
                
                this.cleanupComments();
            }

            getTotalCommentCount(comments) {
                let count = comments.length;
                comments.forEach(comment => {
                    if (comment.replies && comment.replies.length > 0) {
                        count += this.getTotalCommentCount(comment.replies);
                    }
                });
                return count;
            }

            showReplyInput(commentId) {
                const replyInput = document.getElementById(`replyInput-${commentId}`);
                if (replyInput) {
                    replyInput.style.display = 'block';
                    const textarea = replyInput.querySelector('.ab-reply-textarea');
                    if (textarea) {
                        textarea.focus();
                    }
                }
            }

            hideReplyInput(commentId) {
                const replyInput = document.getElementById(`replyInput-${commentId}`);
                if (replyInput) {
                    replyInput.style.display = 'none';
                    const textarea = replyInput.querySelector('.ab-reply-textarea');
                    if (textarea) {
                        textarea.value = '';
                    }
                }
            }

            async submitReply(postId, parentCommentId) {
                const replyInput = document.getElementById(`replyInput-${parentCommentId}`);
                const textarea = replyInput.querySelector('.ab-reply-textarea');
                const content = textarea.value.trim();
                
                if (!content) return;
                
                console.log('üêç Submitting reply:', content, 'to parent:', parentCommentId);
                
                const userReply = {
                    id: Date.now() + Math.random(),
                    author: 'You',
                    user: { avatar: 'üë§', karma: 1, name: 'You' },
                    content: content,
                    votes: 1,
                    timestamp: new Date(),
                    type: 'user',
                    parentId: parentCommentId,
                    replies: []
                };
                
                console.log('üêç Created user reply object:', userReply);
                
                this.addReplyToComment(postId, parentCommentId, userReply);
                
                const post = this.allPosts.find(p => p.id === postId);
                if (post) {
                    post.commentCount++;
                }
                
                this.hideReplyInput(parentCommentId);
                
                console.log('üêç About to refresh modal with updated comments');
                this.openPostModal(post);
                
                setTimeout(() => {
                    this.generateLLMCommentReply(postId, userReply.id, content);
                }, 1000 + Math.random() * 3000);
            }

            addReplyToComment(postId, parentCommentId, reply) {
                const comments = this.postComments[postId];
                console.log('üêç Adding reply to comment. PostId:', postId, 'ParentId:', parentCommentId, 'Reply:', reply.content);
                
                function findAndAddReply(commentList) {
                    for (let comment of commentList) {
                        console.log('üîç Checking comment ID:', comment.id, 'vs ParentID:', parentCommentId, 'Match:', comment.id == parentCommentId);
                        if (comment.id == parentCommentId) { // Use == instead of === to handle string/number comparison
                            if (!comment.replies) comment.replies = [];
                            comment.replies.push(reply);
                            console.log('‚úÖ Reply added successfully! Comment now has', comment.replies.length, 'replies');
                            return true;
                        }
                        if (comment.replies && comment.replies.length > 0) {
                            if (findAndAddReply(comment.replies)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
                
                const success = findAndAddReply(comments);
                if (!success) {
                    console.error('‚ùå Failed to find parent comment with ID:', parentCommentId);
                    console.log('Available comment IDs:', comments.map(c => c.id));
                }
            }

            // FIXED: Generate LLM response as a reply to user's comment
            async generateLLMCommentReply(postId, parentCommentId, userContent) {
                console.log('üêç Generating LLM reply to comment:', userContent);
                
                try {
                    const post = this.allPosts.find(p => p.id === postId);
                    if (!post) return;
                    
                    // Find the original comment author to respond back
                    const originalComment = this.findCommentById(postId, parentCommentId);
                    if (!originalComment || originalComment.author === 'You') return;
                    
                    const responder = originalComment.author;
                    console.log('üêç Original commenter', responder, 'will respond back to user');
                    
                    const response = await this.callLLMService(userContent, post, responder, originalComment);
                    
                    if (response) {
                        console.log('‚úÖ LLM response received:', response);
                        this.addLLMCommentReply(postId, parentCommentId, responder, response);
                    } else {
                        console.log('‚ö†Ô∏è No LLM response, using template fallback');
                        this.addTemplateLLMReply(postId, parentCommentId, responder);
                    }
                } catch (error) {
                    console.error('‚ùå LLM response failed:', error);
                    const originalComment = this.findCommentById(postId, parentCommentId);
                    if (originalComment && originalComment.author !== 'You') {
                        this.addTemplateLLMReply(postId, parentCommentId, originalComment.author);
                    }
                }
            }

            // FIXED: Add LLM reply to specific comment instead of top-level
            addLLMCommentReply(postId, parentCommentId, responder, content) {
                const user = this.users[responder];
                if (!user) return;
                
                const reply = {
                    id: Date.now() + Math.random(),
                    author: responder,
                    user: user,
                    content: content,
                    votes: Math.floor(Math.random() * 10) + 1,
                    timestamp: new Date(),
                    type: 'llm',
                    parentId: parentCommentId,
                    replies: []
                };
                
                this.addReplyToComment(postId, parentCommentId, reply);
                
                const post = this.allPosts.find(p => p.id === postId);
                if (post) {
                    post.commentCount++;
                }
                
                if (this.currentPostId === postId) {
                    this.openPostModal(post);
                }
                
                console.log('‚úÖ LLM reply added:', responder, '‚Üí', content);
            }

            addTemplateLLMReply(postId, parentCommentId, responder) {
                const responses = [
                    "Thanks for sharing this!",
                    "Very interesting perspective",
                    "I hadn't thought of it that way",
                    "Good point!",
                    "This is helpful information",
                    "Appreciate the post!",
                    "Well said",
                    "Completely agree"
                ];
                
                const content = responses[Math.floor(Math.random() * responses.length)];
                this.addLLMCommentReply(postId, parentCommentId, responder, content);
            }

            findCommentById(postId, commentId) {
                const comments = this.postComments[postId];
                
                function searchComments(commentList) {
                    for (let comment of commentList) {
                        if (comment.id == commentId) {
                            return comment;
                        }
                        if (comment.replies && comment.replies.length > 0) {
                            const found = searchComments(comment.replies);
                            if (found) return found;
                        }
                    }
                    return null;
                }
                
                return searchComments(comments);
            }

            async callLLMService(userComment, post, responder) {
                console.log('üêç Calling LLM service for:', responder);
                
                let apiKey = null;
                let selectedModel = 'gemini-pro';
                
                try {
                    // Try to load API settings from messenger (if available)
                    if (typeof(Storage) !== "undefined") {
                        const messengerSettings = localStorage.getItem('snakesia-messenger-settings');
                        if (messengerSettings) {
                            const settings = JSON.parse(messengerSettings);
                            apiKey = settings.apiKey;
                            selectedModel = settings.selectedModel || 'gemini-pro';
                            console.log('üîë Loaded API settings from messenger system');
                        }
                    }
                } catch (error) {
                    console.log('‚ö†Ô∏è No messenger settings available');
                }
                
                if (!apiKey) {
                    console.log('‚ö†Ô∏è No API key available');
                    return null;
                }
                
                try {
                    const prompt = this.buildLLMPrompt(userComment, post, responder);
                    const response = await this.callGeminiAPI(prompt, apiKey, selectedModel);
                    
                    if (response) {
                        return this.processLLMResponse(response);
                    } else {
                        throw new Error('Empty response from LLM');
                    }
                    
                } catch (error) {
                    console.error('‚ùå LLM generation failed:', error);
                    return null;
                }
            }

            async callGeminiAPI(prompt, apiKey, selectedModel) {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: prompt
                                }]
                            }],
                            generationConfig: {
                                maxOutputTokens: 200,
                                temperature: 0.8,
                                topP: 0.9
                            }
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Gemini API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts[0]) {
                        return data.candidates[0].content.parts[0].text;
                    } else {
                        return null;
                    }
                } catch (error) {
                    console.error('üö´ Gemini API call failed:', error);
                    return null;  
                }
            }

            buildLLMPrompt(userComment, post, responder) {
                const characterInfo = this.getCharacterInfo(responder);
                const subbabbit = this.subbabbits[post.subbabbit];
                const snakesiaTime = this.getSnakesiaTime();
                
                return `You are ${responder} commenting on a post in Abbit (like Reddit) for Snakesia. ${characterInfo.description}

CONTEXT:
- Current time in Snakesia: ${snakesiaTime}
- Subbabbit: ${subbabbit.name} - ${subbabbit.description}
- Original Post: "${post.title}"
- Post Content: "${post.content}"
- Post Author: ${post.author}

A user just commented: "${userComment}"

RESPONSE RULES:
- Respond as ${responder} in a Reddit-style comment
- Keep it SHORT: 1-2 sentences maximum  
- Be conversational and natural
- Stay in character
- React naturally to the user's comment
- Don't be overly helpful or formal
- Use casual Reddit-style language

Response as ${responder}:`;
            }

            getCharacterInfo(responder) {
                const characterMap = {
                    'RemiMarway': { 
                        description: 'You are Remi, a cool 12-year-old YouTuber and Minecraft player. You talk casually like "yo", "dude", "nice". You love gaming, making videos, and building in Minecraft.' 
                    },
                    'Snake_E_CEO': { 
                        description: 'You are Mr. Snake-e, the 60-year-old CEO of ElxaCorp. You are intelligent, business-minded, and successful but friendly. You speak professionally but warmly.' 
                    },
                    'Mrs_Snake_E': { 
                        description: 'You are Mrs. Snake-e, an 80-year-old sweet grandmother who loves gardening and cooking. You are very motherly and caring, calling people "dear".' 
                    },
                    'PushingCat': { 
                        description: 'You are Pushing Cat, a mischievous black cat who is very "sus" and playful. You like to cause harmless trouble and make cat sounds like "*purr*".' 
                    }
                };
                
                return characterMap[responder] || { description: 'You are a friendly member of the Snakesia community.' };
            }

            getSnakesiaTime() {
                const now = new Date();
                const snakesiaTime = new Date(now.getTime() + (2 * 60 + 1) * 60 * 1000);
                return snakesiaTime.toLocaleString('en-US', {
                    weekday: 'long',
                    hour: '2-digit',
                    minute: '2-digit',
                    timeZoneName: 'short'
                }) + ' (Snakesia Time)';
            }

            processLLMResponse(rawResponse) {
                let processed = rawResponse.trim();
                
                if (processed.length > 300) {
                    const sentences = processed.match(/[^\.!?]*[\.!?]+/g) || [];
                    let truncated = '';
                    for (const sentence of sentences) {
                        if ((truncated + sentence).length <= 250) {
                            truncated += sentence;
                        } else {
                            break;
                        }
                    }
                    
                    if (truncated.length > 50) {
                        processed = truncated.trim();
                    } else {
                        processed = processed.substring(0, 250).trim() + '...';
                    }
                }
                
                return processed;
            }

            // FIXED: Comment voting with proper state management
            voteComment(postId, commentId, direction) {
                console.log('üêç Voting on comment:', commentId, direction);
                const comments = this.postComments[postId];
                
                function findAndVoteComment(commentList) {
                    for (let comment of commentList) {
                        if (comment.id == commentId) { // Use == instead of === for string/number comparison
                            console.log('‚úÖ Found comment to vote on:', comment.content);
                            
                            // Initialize vote state if not present
                            if (!comment.hasOwnProperty('userUpvoted')) {
                                comment.userUpvoted = false;
                                comment.userDownvoted = false;
                            }
                            
                            if (direction === 'up') {
                                if (comment.userUpvoted) {
                                    // Remove upvote
                                    comment.userUpvoted = false;
                                    comment.votes--;
                                } else {
                                    // Add upvote
                                    if (comment.userDownvoted) {
                                        comment.userDownvoted = false;
                                        comment.votes++; // Remove downvote first
                                    }
                                    comment.userUpvoted = true;
                                    comment.votes++;
                                }
                            } else if (direction === 'down') {
                                if (comment.userDownvoted) {
                                    // Remove downvote
                                    comment.userDownvoted = false;
                                    comment.votes++;
                                } else {
                                    // Add downvote
                                    if (comment.userUpvoted) {
                                        comment.userUpvoted = false;
                                        comment.votes--; // Remove upvote first
                                    }
                                    comment.userDownvoted = true;
                                    comment.votes--;
                                }
                            }
                            
                            console.log('‚úÖ Comment vote updated. New score:', comment.votes);
                            return true;
                        }
                        if (comment.replies && comment.replies.length > 0) {
                            if (findAndVoteComment(comment.replies)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
                
                if (findAndVoteComment(comments)) {
                    // Re-render the modal to update the vote display
                    const post = this.allPosts.find(p => p.id === postId);
                    if (post && this.currentPostId === postId) {
                        this.openPostModal(post);
                    }
                } else {
                    console.error('‚ùå Comment not found for voting:', commentId);
                }
            }

            cleanupComments() {
                const postIds = Object.keys(this.postComments);
                console.log(`üßπ Cleaning up ${postIds.length} post comment caches`);
                
                postIds.forEach(postId => {
                    if (this.postComments[postId].length > this.maxComments) {
                        this.postComments[postId] = this.postComments[postId].slice(-this.maxComments);
                        console.log(`üßπ Trimmed ${postId} to ${this.maxComments} comments`);
                    }
                });
                
                if (postIds.length > 20) {
                    const sortedIds = postIds.sort();
                    const idsToRemove = sortedIds.slice(0, postIds.length - 20);
                    idsToRemove.forEach(id => {
                        delete this.postComments[id];
                        console.log(`üßπ Removed old post comment cache: ${id}`);
                    });
                }
            }

            closeModal() {
                document.getElementById('postModal').style.display = 'none';
                this.currentPostId = null;
            }

            searchPosts(query) {
                console.log('üêç Searching for:', query);
                const searchResults = this.allPosts.filter(post =>
                    post.title.toLowerCase().includes(query.toLowerCase()) ||
                    post.content.toLowerCase().includes(query.toLowerCase())
                );
                
                this.posts = searchResults;
                this.renderPosts();
                
                document.getElementById('feedTitle').textContent = `Search results for "${query}"`;
            }
        }

        // Initialize the app
        function initAbbit() {
            console.log('üêç Abbit: Starting initialization...');
            try {
                window.abbitApp = new AbbitApp();
                console.log('‚úÖ Abbit: App initialized successfully');
            } catch (error) {
                console.error('‚ùå Abbit: Failed to initialize:', error);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initAbbit);
        } else {
            initAbbit();
        }

        setTimeout(() => {
            if (!window.abbitApp) {
                console.log('üêç Abbit: Fallback initialization...');
                initAbbit();
            }
        }, 500);
    </script>
</body>
</html>