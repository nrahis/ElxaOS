<!DOCTYPE html>
<html>
<head>
    <title>Dissscord - Chat for Snakesia</title>
    <link rel="stylesheet" href="./assets/interwebs/dissscord/styles.css">
</head>
<body>
    <div class="ds-container">
        <!-- Server List -->
        <div class="ds-servers">
            <div class="ds-server-icon active" data-server="remi" title="Remi's Gaming Hub">
                üéÆ
            </div>
            <div class="ds-server-icon" data-server="elxacorp" title="ElxaCorp Official">
                üè¢
            </div>
            <div class="ds-server-icon" data-server="snakesia" title="Snakesia Community">
                üêç
            </div>
            <div class="ds-server-icon" data-server="mansion" title="Snake-e Mansion">
                üè∞
            </div>
            <div class="ds-server-icon" data-server="sussy" title="Sussy Lair">
                üòà
            </div>
        </div>

        <!-- Channels -->
        <div class="ds-channels">
            <div class="ds-server-header" id="serverName">Remi's Gaming Hub</div>
            
            <div id="channelsList">
                <!-- Channels will be populated by JavaScript -->
            </div>
        </div>

        <!-- Main Chat -->
        <div class="ds-main">
            <div class="ds-chat-header">
                <span class="ds-chat-name" id="channelName"># general</span>
                <span class="ds-chat-topic" id="channelTopic">General discussion</span>
            </div>
            
            <div class="ds-messages" id="messageContainer">
                <div class="ds-loading">Loading messages...</div>
            </div>

            <div id="typingIndicator" class="ds-typing" style="display: none;">
                <span id="typingUser">Someone</span> is typing<span class="ds-typing-dots">...</span>
            </div>

            <div class="ds-message-input-container">
                <textarea 
                    class="ds-message-input" 
                    id="messageInput" 
                    placeholder="Message #general"
                    maxlength="2000"
                    rows="1"
                ></textarea>
            </div>
        </div>

        <!-- Members List -->
        <div class="ds-members" id="membersList">
            <!-- Members will be populated by JavaScript -->
        </div>
    </div>

    <script>
        console.log('üéÆ Dissscord: JavaScript loaded');
        
        class DissscordApp {
            constructor() {
                console.log('üéÆ Dissscord: Constructor starting...');
                
                this.currentServer = 'remi';
                this.currentChannel = 'general';
                this.messages = []; // Current channel messages
                this.channelMessages = {}; // Persistent messages per server/channel
                this.maxMessages = 30; // Reduced from 100 to save memory
                this.messageGenerationActive = false;
                this.typingTimeouts = new Map();
                this.userCanSend = true;
                this.llmService = null;
                this.messageTimeout = null;
                this.messageObserver = null;
                
                console.log('üéÆ Dissscord: Basic properties set');
                
                // Initialize asynchronously
                this.initialize();
            }

            async initialize() {
                try {
                    await this.initializeData();
                    console.log('üéÆ Dissscord: Data initialized');
                    
                    this.setupEventListeners();
                    console.log('üéÆ Dissscord: Event listeners set up');
                    
                    this.loadServer('remi');
                    console.log('üéÆ Dissscord: Server loaded');
                    
                    this.startMessageGeneration();
                    console.log('üéÆ Dissscord: Message generation started');
                } catch (error) {
                    console.error('‚ùå Dissscord: Initialization error:', error);
                    
                    // Show error message to user
                    const messageContainer = document.getElementById('messageContainer');
                    if (messageContainer) {
                        messageContainer.innerHTML = `
                            <div class="ds-loading" style="color: #ff6b6b;">
                                ‚ùå Failed to load Dissscord data: ${error.message}
                                <br><br>
                                Please make sure the dissscord-data.json file exists in the correct location.
                            </div>
                        `;
                    }
                }
            }

            async initializeData() {
                console.log('üéÆ Loading data from dissscord-data.json...');
                
                try {
                    // Load data from external JSON file
                    const data = await this.loadDataFile();
                    
                    // Set properties from loaded data
                    this.servers = data.servers;
                    this.messageTemplates = data.messageTemplates;
                    this.messageVariables = data.messageVariables;
                    
                    console.log('‚úÖ Data loaded successfully');
                    console.log('üìä Servers loaded:', Object.keys(this.servers).length);
                    console.log('üìù Message templates loaded:', Object.keys(this.messageTemplates).length);
                    console.log('üî§ Message variables loaded:', Object.keys(this.messageVariables).length);
                    
                } catch (error) {
                    console.error('‚ùå Failed to load data:', error);
                    // Fall back to empty data structures to prevent crashes
                    this.servers = {};
                    this.messageTemplates = {};
                    this.messageVariables = {};
                    throw new Error('Failed to load Dissscord data: ' + error.message);
                }
            }

            async loadDataFile() {
                const possiblePaths = [
                    // ElxaOS file system paths
                    'dissscord-data.json',
                    './assets/interwebs/dissscord/dissscord-data.json',
                    // Fetch API paths
                    './dissscord-data.json',
                    './assets/interwebs/dissscord/dissscord-data.json',
                    'assets/interwebs/dissscord/dissscord-data.json'
                ];
                
                // Try ElxaOS file system API first
                if (window.fs && window.fs.readFile) {
                    console.log('üéÆ Using ElxaOS file system...');
                    for (const path of possiblePaths.slice(0, 2)) {
                        try {
                            console.log(`üéÆ Trying ElxaOS path: ${path}`);
                            const fileData = await window.fs.readFile(path, { encoding: 'utf8' });
                            console.log(`‚úÖ Successfully loaded from ElxaOS: ${path}`);
                            return JSON.parse(fileData);
                        } catch (error) {
                            console.log(`‚ö†Ô∏è ElxaOS path failed: ${path} - ${error.message}`);
                            continue;
                        }
                    }
                }
                
                // Fallback to fetch API with multiple path attempts
                console.log('üéÆ Using fetch API...');
                for (const path of possiblePaths.slice(2)) {
                    try {
                        console.log(`üéÆ Trying fetch path: ${path}`);
                        const response = await fetch(path);
                        if (response.ok) {
                            console.log(`‚úÖ Successfully loaded from fetch: ${path}`);
                            return await response.json();
                        }
                        console.log(`‚ö†Ô∏è Fetch path failed: ${path} - HTTP ${response.status}`);
                    } catch (error) {
                        console.log(`‚ö†Ô∏è Fetch path error: ${path} - ${error.message}`);
                        continue;
                    }
                }
                
                throw new Error('Could not find dissscord-data.json in any expected location');
            }

            setupEventListeners() {
                console.log('üéÆ Setting up event listeners...');
                
                // Clean up existing observer if any
                if (this.messageObserver) {
                    this.messageObserver.disconnect();
                    this.messageObserver = null;
                }
                
                // Server switching
                document.querySelectorAll('.ds-server-icon').forEach(server => {
                    server.addEventListener('click', (e) => {
                        const serverId = e.target.dataset.server;
                        console.log('üéÆ Server clicked:', serverId);
                        if (serverId) {
                            this.loadServer(serverId);
                        }
                    });
                });

                // Message input
                const messageInput = document.getElementById('messageInput');
                if (messageInput) {
                    console.log('‚úÖ Message input found, adding listeners');
                    
                    messageInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            console.log('üéÆ Enter pressed, sending message...');
                            this.sendUserMessage();
                        }
                    });

                    messageInput.addEventListener('input', (e) => {
                        // Auto-resize textarea
                        e.target.style.height = 'auto';
                        e.target.style.height = Math.min(e.target.scrollHeight, 144) + 'px';
                        
                        // Update placeholder
                        const channelName = document.getElementById('channelName').textContent;
                        e.target.placeholder = `Message ${channelName}`;
                    });
                } else {
                    console.error('‚ùå Message input not found!');
                }

                // Simplified auto-scroll (less memory intensive)
                const messageContainer = document.getElementById('messageContainer');
                if (messageContainer) {
                    // Use a simpler approach - just scroll after updates
                    this.scrollToBottom = () => {
                        messageContainer.scrollTop = messageContainer.scrollHeight;
                    };
                    console.log('‚úÖ Scroll function set up');
                } else {
                    console.error('‚ùå Message container not found!');
                }
                
                console.log('‚úÖ Event listeners setup complete');
            }

            loadServer(serverId) {
                console.log('üéÆ Loading server:', serverId);
                
                // Save current channel messages before switching servers
                this.saveCurrentChannelMessages();
                
                this.currentServer = serverId;
                this.currentChannel = 'general';
                
                // Update server selection
                document.querySelectorAll('.ds-server-icon').forEach(icon => {
                    icon.classList.remove('active');
                });
                const serverElement = document.querySelector(`[data-server="${serverId}"]`);
                if (serverElement) {
                    serverElement.classList.add('active');
                }
                
                // Update server name
                document.getElementById('serverName').textContent = this.servers[serverId].name;
                
                // Load channels
                this.loadChannels(serverId);
                
                // Load members
                this.loadMembers(serverId);
                
                // Load channel (default to general) - this will handle message loading
                this.loadChannel('general');
                
                // Clean up old messages periodically to prevent memory buildup
                this.cleanupChannelMessages();
                
                console.log('‚úÖ Server loaded:', serverId);
            }

            loadChannels(serverId) {
                const channelsList = document.getElementById('channelsList');
                const channels = this.servers[serverId].channels;
                
                let html = '<div class="ds-channel-category">Text Channels</div>';
                
                Object.entries(channels).forEach(([channelId, channel]) => {
                    if (channel.type === 'text') {
                        const isActive = channelId === this.currentChannel ? 'active' : '';
                        html += `
                            <div class="ds-channel ${isActive}" data-channel="${channelId}">
                                <span class="ds-channel-prefix">#</span>
                                <span class="ds-channel-name">${channel.name}</span>
                            </div>
                        `;
                    }
                });
                
                // Add voice channels if any
                const voiceChannels = Object.entries(channels).filter(([_, channel]) => channel.type === 'voice');
                if (voiceChannels.length > 0) {
                    html += '<div class="ds-channel-category">Voice Channels</div>';
                    voiceChannels.forEach(([channelId, channel]) => {
                        html += `
                            <div class="ds-channel" data-channel="${channelId}">
                                <span class="ds-channel-prefix">üîä</span>
                                <span class="ds-channel-name">${channel.name}</span>
                            </div>
                        `;
                    });
                }
                
                channelsList.innerHTML = html;
                
                // Add channel click listeners
                document.querySelectorAll('.ds-channel').forEach(channel => {
                    channel.addEventListener('click', (e) => {
                        const channelId = e.target.closest('.ds-channel').dataset.channel;
                        if (channelId && this.servers[this.currentServer].channels[channelId].type === 'text') {
                            this.loadChannel(channelId);
                        }
                    });
                });
            }

            loadChannel(channelId) {
                console.log('üéÆ Loading channel:', channelId, 'in server:', this.currentServer);
                
                // Save current channel messages before switching
                this.saveCurrentChannelMessages();
                
                // Update current channel
                this.currentChannel = channelId;
                const channel = this.servers[this.currentServer].channels[channelId];
                
                // Update channel selection UI
                document.querySelectorAll('.ds-channel').forEach(ch => {
                    ch.classList.remove('active');
                });
                const channelElement = document.querySelector(`[data-channel="${channelId}"]`);
                if (channelElement) {
                    channelElement.classList.add('active');
                }
                
                // Update channel header
                document.getElementById('channelName').textContent = `# ${channel.name}`;
                document.getElementById('channelTopic').textContent = channel.topic;
                
                // Update message input placeholder
                document.getElementById('messageInput').placeholder = `Message #${channel.name}`;
                
                // Load saved messages for this channel
                const hasMessages = this.loadChannelMessages(this.currentServer, channelId);
                this.updateMessageDisplay();
                
                // Only generate new messages if channel is empty
                if (!hasMessages) {
                    // Stop current generation and restart for new channel
                    this.stopMessageGeneration();
                    
                    // Start generation after a brief delay
                    setTimeout(() => {
                        this.startMessageGeneration();
                    }, 100);
                }
                
                console.log('‚úÖ Channel loaded:', channelId);
            }

            loadMembers(serverId) {
                const membersList = document.getElementById('membersList');
                const members = this.servers[serverId].members;
                
                let html = '';
                
                if (members.online.length > 0) {
                    html += `<div class="ds-members-category">Online ‚Äî ${members.online.length}</div>`;
                    members.online.forEach(member => {
                        const roleClass = member.role ? `ds-role-${member.role}` : '';
                        html += `
                            <div class="ds-member">
                                <div class="ds-member-avatar">${member.avatar}</div>
                                <div class="ds-member-name">${member.name}</div>
                            </div>
                        `;
                    });
                }
                
                if (members.away.length > 0) {
                    html += `<div class="ds-members-category">Away ‚Äî ${members.away.length}</div>`;
                    members.away.forEach(member => {
                        html += `
                            <div class="ds-member">
                                <div class="ds-member-avatar" style="opacity: 0.5">${member.avatar}</div>
                                <div class="ds-member-name" style="opacity: 0.5">${member.name}</div>
                            </div>
                        `;
                    });
                }
                
                membersList.innerHTML = html;
            }

            startMessageGeneration() {
                if (this.messageGenerationActive) return;
                
                this.messageGenerationActive = true;
                
                // Generate a few initial messages immediately
                console.log('üéÆ Starting message generation...');
                this.generateInitialMessages();
                
                // Then start the regular generation cycle
                this.generateNextMessage();
            }

            generateInitialMessages() {
                console.log('üéÆ Dissscord: Generating initial messages...');
                
                // Add one test message first to make sure the system works
                const testMessage = {
                    id: Date.now(),
                    author: 'RemiMarway',
                    authorInfo: {
                        avatar: 'üéÆ',
                        role: 'owner',
                        status: 'online'
                    },
                    text: 'Welcome to Dissscord! This is working!',
                    timestamp: new Date(),
                    type: 'test'
                };
                
                this.addMessage(testMessage);
                console.log('üéÆ Dissscord: Added test message');
                
                // Generate 3-5 initial messages to populate the chat
                const initialCount = Math.floor(Math.random() * 3) + 2; // 2-4 more messages
                
                for (let i = 0; i < initialCount; i++) {
                    const message = this.createRandomMessage();
                    if (message) {
                        // Add some time variation to make messages look older
                        message.timestamp = new Date(Date.now() - (initialCount - i) * 60000 * Math.random() * 30);
                        this.addMessage(message);
                        console.log('üéÆ Generated initial message:', message.author, message.text);
                    } else {
                        console.error('‚ùå Failed to create initial message for', this.currentServer, this.currentChannel);
                        // Add a fallback message
                        const fallbackMessage = {
                            id: Date.now() + i,
                            author: 'System',
                            authorInfo: { avatar: 'ü§ñ', role: 'member', status: 'online' },
                            text: 'Chat system is loading...',
                            timestamp: new Date(Date.now() - (initialCount - i) * 60000),
                            type: 'fallback'
                        };
                        this.addMessage(fallbackMessage);
                    }
                }
                
                console.log('üéÆ Dissscord: Initial messages complete, total:', this.messages.length);
            }

            saveCurrentChannelMessages() {
                // Save current messages to persistent storage
                const key = `${this.currentServer}:${this.currentChannel}`;
                if (this.messages.length > 0) {
                    this.channelMessages[key] = [...this.messages];
                    console.log(`üíæ Saved ${this.messages.length} messages for ${key}`);
                }
            }

            loadChannelMessages(serverId, channelId) {
                // Load messages for specific server/channel
                const key = `${serverId}:${channelId}`;
                const savedMessages = this.channelMessages[key];
                
                if (savedMessages && savedMessages.length > 0) {
                    this.messages = [...savedMessages];
                    console.log(`üìÇ Loaded ${this.messages.length} messages for ${key}`);
                    return true;
                } else {
                    this.messages = [];
                    console.log(`üìÇ No saved messages for ${key}, starting fresh`);
                    return false;
                }
            }

            cleanupChannelMessages() {
                // Clean up old messages to prevent memory buildup
                const keys = Object.keys(this.channelMessages);
                console.log(`üßπ Cleaning up ${keys.length} channel message caches`);
                
                // Keep only the most recent messages per channel
                keys.forEach(key => {
                    if (this.channelMessages[key].length > this.maxMessages) {
                        this.channelMessages[key] = this.channelMessages[key].slice(-this.maxMessages);
                    }
                });
            }

            stopMessageGeneration() {
                this.messageGenerationActive = false;
                if (this.messageTimeout) {
                    clearTimeout(this.messageTimeout);
                    this.messageTimeout = null;
                    console.log('‚èπÔ∏è Message generation stopped and timeout cleared');
                }
            }

            generateNextMessage() {
                if (!this.messageGenerationActive) return;
                
                console.log('üéÆ Generating next message for', this.currentServer, this.currentChannel);
                
                // Generate a message for current server/channel
                const message = this.createRandomMessage();
                if (message) {
                    this.addMessage(message);
                    console.log('‚úÖ Generated message:', message.author, message.text);
                } else {
                    console.error('‚ùå Failed to generate message for', this.currentServer, this.currentChannel);
                }
                
                // Schedule next message (2-8 minutes instead of 30 seconds-3 minutes to reduce memory usage)
                const delay = Math.random() * (480000 - 120000) + 120000; // 2-8 minutes
                console.log(`‚è∞ Next message in ${Math.round(delay/60000)} minutes`);
                this.messageTimeout = setTimeout(() => {
                    this.generateNextMessage();
                }, delay);
            }

            createRandomMessage() {
                const serverTemplates = this.messageTemplates[this.currentServer];
                if (!serverTemplates) return null;
                
                const channelTemplates = serverTemplates[this.currentChannel];
                if (!channelTemplates || channelTemplates.length === 0) return null;
                
                // Weighted random selection
                const totalWeight = channelTemplates.reduce((sum, template) => sum + template.weight, 0);
                let random = Math.random() * totalWeight;
                
                let selectedTemplate = null;
                for (const template of channelTemplates) {
                    random -= template.weight;
                    if (random <= 0) {
                        selectedTemplate = template;
                        break;
                    }
                }
                
                if (!selectedTemplate) {
                    selectedTemplate = channelTemplates[0];
                }
                
                // Replace variables in message text
                const messageText = this.replaceMessageVariables(selectedTemplate.text);
                
                // Get author info
                const authorInfo = this.getAuthorInfo(selectedTemplate.author);
                
                return {
                    id: Date.now() + Math.random(),
                    author: selectedTemplate.author,
                    authorInfo: authorInfo,
                    text: messageText,
                    timestamp: new Date(),
                    type: 'generated'
                };
            }

            replaceMessageVariables(text) {
                // Find all {{variable}} patterns
                return text.replace(/\{\{([^}]+)\}\}/g, (match, variableName) => {
                    const values = this.messageVariables[variableName];
                    if (values && values.length > 0) {
                        return values[Math.floor(Math.random() * values.length)];
                    }
                    return match; // Return original if variable not found
                });
            }

            getAuthorInfo(authorName) {
                // Find author in current server's members
                const serverMembers = this.servers[this.currentServer].members;
                const allMembers = [...serverMembers.online, ...serverMembers.away];
                
                const member = allMembers.find(m => m.name === authorName);
                if (member) {
                    return {
                        avatar: member.avatar,
                        role: member.role,
                        status: member.status
                    };
                }
                
                // Default fallback
                return {
                    avatar: 'üë§',
                    role: 'member',
                    status: 'online'
                };
            }

            addMessage(message) {
                this.messages.push(message);
                
                // Keep only last maxMessages
                if (this.messages.length > this.maxMessages) {
                    this.messages = this.messages.slice(-this.maxMessages);
                }
                
                this.updateMessageDisplay();
            }

            updateMessageDisplay() {
                const container = document.getElementById('messageContainer');
                
                if (this.messages.length === 0) {
                    container.innerHTML = '<div class="ds-loading">No messages yet... generating content...</div>';
                    return;
                }
                
                // Build HTML more efficiently
                const htmlParts = [];
                this.messages.forEach((message, index) => {
                    const roleClass = message.authorInfo.role ? `ds-role-${message.authorInfo.role}` : '';
                    const roleText = message.authorInfo.role && message.authorInfo.role !== 'member' ? 
                        `<span class="ds-role ${roleClass}">${message.authorInfo.role}</span>` : '';
                    
                    const messageClass = message.type === 'user' ? 'ds-message user-message' : 'ds-message';
                    
                    htmlParts.push(`
                        <div class="${messageClass}">
                            <div class="ds-avatar">${message.authorInfo.avatar}</div>
                            <div class="ds-message-content">
                                <div class="ds-message-header">
                                    <span class="ds-username">${message.author}</span>
                                    ${roleText}
                                    <span class="ds-timestamp">${this.formatTimestamp(message.timestamp)}</span>
                                </div>
                                <div class="ds-message-text">${this.formatMessageText(message.text)}</div>
                            </div>
                        </div>
                    `);
                });
                
                container.innerHTML = htmlParts.join('');
                
                // Use the simpler scroll method
                if (this.scrollToBottom) {
                    this.scrollToBottom();
                }
            }

            formatMessageText(text) {
                // Format mentions
                text = text.replace(/@(\w+)/g, '<span class="ds-mention">@$1</span>');
                
                // Format emojis (basic)
                text = text.replace(/:\w+:/g, (match) => {
                    const emojiMap = {
                        ':smile:': 'üòä',
                        ':laugh:': 'üòÇ',
                        ':heart:': '‚ù§Ô∏è',
                        ':fire:': 'üî•',
                        ':thumbsup:': 'üëç'
                    };
                    return emojiMap[match] || match;
                });
                
                return text;
            }

            formatTimestamp(timestamp) {
                const now = new Date();
                const diff = now - timestamp;
                
                if (diff < 60000) { // Less than 1 minute
                    return 'just now';
                } else if (diff < 3600000) { // Less than 1 hour
                    const minutes = Math.floor(diff / 60000);
                    return `${minutes}m ago`;
                } else if (diff < 86400000) { // Less than 1 day
                    const hours = Math.floor(diff / 3600000);
                    return `${hours}h ago`;
                } else {
                    return timestamp.toLocaleDateString();
                }
            }

            sendUserMessage() {
                const input = document.getElementById('messageInput');
                const text = input.value.trim();
                
                console.log('üéÆ User trying to send message:', text);
                
                if (!text || !this.userCanSend) {
                    console.log('‚ö†Ô∏è Message empty or user cannot send');
                    return;
                }
                
                console.log('‚úÖ Sending user message:', text);
                
                // Create user message
                const userMessage = {
                    id: Date.now() + Math.random(),
                    author: 'You',
                    authorInfo: {
                        avatar: 'üë§',
                        role: 'member',
                        status: 'online'
                    },
                    text: text,
                    timestamp: new Date(),
                    type: 'user'
                };
                
                this.addMessage(userMessage);
                console.log('‚úÖ User message added to chat');
                
                // Clear input
                input.value = '';
                input.style.height = 'auto';
                
                // Show typing indicator and schedule LLM response
                this.handleUserMessage(text);
            }

            async handleUserMessage(messageText) {
                console.log('üéÆ Handling user message:', messageText);
                
                // Check if user mentioned a specific character
                const mentionedCharacter = this.findMentionedCharacter(messageText);
                console.log('üéÆ Mentioned character:', mentionedCharacter);
                
                if (mentionedCharacter) {
                    // Respond as specific character
                    console.log('üéÆ Showing typing indicator for:', mentionedCharacter);
                    this.showTypingIndicator(mentionedCharacter);
                    await this.generateLLMResponse(messageText, mentionedCharacter);
                } else {
                    // Random chance for someone to respond
                    if (Math.random() < 0.7) { // 70% chance
                        const randomCharacter = this.getRandomActiveCharacter();
                        console.log('üéÆ Random character selected to respond:', randomCharacter);
                        if (randomCharacter) {
                            this.showTypingIndicator(randomCharacter);
                            await this.generateLLMResponse(messageText, randomCharacter);
                        } else {
                            console.log('üéÆ No active characters available for random response');
                        }
                    } else {
                        console.log('üéÆ Random roll failed, no character response');
                    }
                }
            }

            findMentionedCharacter(messageText) {
                const serverMembers = this.servers[this.currentServer].members;
                const allMembers = [...serverMembers.online, ...serverMembers.away];
                
                // Check for @mentions or name mentions
                for (const member of allMembers) {
                    const name = member.name.toLowerCase();
                    const text = messageText.toLowerCase();
                    
                    if (text.includes(`@${name}`) || text.includes(name)) {
                        return member.name;
                    }
                }
                
                return null;
            }

            getRandomActiveCharacter() {
                const serverMembers = this.servers[this.currentServer].members;
                const activeMembers = serverMembers.online.filter(member => member.name !== 'You');
                
                if (activeMembers.length === 0) return null;
                
                return activeMembers[Math.floor(Math.random() * activeMembers.length)].name;
            }

            showTypingIndicator(characterName) {
                const indicator = document.getElementById('typingIndicator');
                const userSpan = document.getElementById('typingUser');
                
                userSpan.textContent = characterName;
                indicator.style.display = 'block';
                
                // Hide after a delay
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 3000);
            }

            async generateLLMResponse(userMessage, characterName) {
                console.log('üéÆ Generating LLM response for:', characterName, 'Message:', userMessage);
                
                try {
                    // Try to use LLM service (similar to messenger/email)
                    const response = await this.callLLMService(userMessage, characterName);
                    
                    if (response) {
                        console.log('‚úÖ LLM response received:', response);
                        // Add delay to simulate typing
                        setTimeout(() => {
                            this.addCharacterResponse(characterName, response);
                        }, 2000 + Math.random() * 3000);
                    } else {
                        console.log('‚ö†Ô∏è No LLM response, using template fallback');
                        // Fallback to template response
                        setTimeout(() => {
                            this.addTemplateResponse(characterName, userMessage);
                        }, 2000 + Math.random() * 3000);
                    }
                } catch (error) {
                    console.error('‚ùå LLM response failed:', error);
                    // Fallback to template response
                    setTimeout(() => {
                        this.addTemplateResponse(characterName, userMessage);
                    }, 2000 + Math.random() * 3000);
                }
            }

            async callLLMService(userMessage, characterName) {
                console.log('üéÆ Calling LLM service for:', characterName);
                
                // Load API settings from messenger (same as email system does)
                let apiKey = null;
                let selectedModel = 'gemini-pro';
                
                try {
                    const messengerSettings = localStorage.getItem('snakesia-messenger-settings');
                    if (messengerSettings) {
                        const settings = JSON.parse(messengerSettings);
                        apiKey = settings.apiKey;
                        selectedModel = settings.selectedModel || 'gemini-pro';
                        console.log('üîë Loaded API settings from messenger system');
                    } else {
                        console.log('‚ö†Ô∏è No messenger settings found, API not available');
                        return null;
                    }
                } catch (error) {
                    console.error('‚ùå Failed to load LLM settings:', error);
                    return null;
                }
                
                if (!apiKey) {
                    console.log('‚ö†Ô∏è No API key available');
                    return null;
                }
                
                try {
                    console.log(`ü§ñ Generating LLM response for ${characterName}`);
                    
                    // Build the LLM prompt
                    const prompt = this.buildLLMPrompt(userMessage, characterName);
                    console.log(`üìù Prompt length: ${prompt.length} characters`);
                    
                    // Make API call to Gemini (same as email system)
                    const response = await this.callGeminiAPI(prompt, apiKey, selectedModel);
                    
                    if (response) {
                        console.log('‚úÖ LLM response generated successfully');
                        return this.processLLMResponse(response);
                    } else {
                        throw new Error('Empty response from LLM');
                    }
                    
                } catch (error) {
                    console.error('‚ùå LLM generation failed:', error);
                    return null;
                }
            }

            async callGeminiAPI(prompt, apiKey, selectedModel) {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: prompt
                                }]
                            }],
                            generationConfig: {
                                maxOutputTokens: 150, // Short Discord-style responses
                                temperature: 0.8,
                                topP: 0.9
                            },
                            safetySettings: [
                                {
                                    category: "HARM_CATEGORY_HARASSMENT",
                                    threshold: "BLOCK_MEDIUM_AND_ABOVE"
                                },
                                {
                                    category: "HARM_CATEGORY_HATE_SPEECH", 
                                    threshold: "BLOCK_MEDIUM_AND_ABOVE"
                                }
                            ]
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Gemini API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts[0]) {
                        return data.candidates[0].content.parts[0].text;
                    } else {
                        console.error('üö´ Invalid API response format:', data);
                        return null;
                    }
                } catch (error) {
                    console.error('üö´ Gemini API call failed:', error);
                    return null;  
                }
            }

            processLLMResponse(rawResponse) {
                // Clean up the response for Discord-style chat
                let processed = rawResponse.trim();
                
                // Hard limit: Keep messages Discord-appropriate length (about 300 characters max)
                if (processed.length > 300) {
                    // Try to cut at a natural break point (sentence end)
                    const sentences = processed.match(/[^\.!?]*[\.!?]+/g) || [];
                    let truncated = '';
                    for (const sentence of sentences) {
                        if ((truncated + sentence).length <= 250) {
                            truncated += sentence;
                        } else {
                            break;
                        }
                    }
                    
                    if (truncated.length > 50) {
                        processed = truncated.trim();
                    } else {
                        // Fallback: hard cut with ellipsis
                        processed = processed.substring(0, 250).trim() + '...';
                    }
                }
                
                return processed;
            }

            buildLLMPrompt(userMessage, characterName) {
                // Build prompt similar to messenger/email but for Discord-style chat
                const character = this.getCharacterInfo(characterName);
                const context = this.getCurrentContext();
                
                // Get some recent messages for context (last 3)
                const recentMessages = this.messages.slice(-3).map(msg => 
                    `${msg.author}: ${msg.text}`
                ).join('\n');
                
                const snakesiaTime = this.getSnakesiaTime();
                
                return `You are ${characterName} in a Discord-like chat server called Dissscord. ${character.description}

CONTEXT:
- Current time in Snakesia: ${snakesiaTime}
- Server: ${this.servers[this.currentServer].name}
- Channel: #${this.servers[this.currentServer].channels[this.currentChannel].name}
- Topic: ${this.servers[this.currentServer].channels[this.currentChannel].topic}

RECENT CHAT:
${recentMessages}

User just said: "${userMessage}"

RESPONSE RULES:
- Respond as ${characterName} in casual Discord chat style
- Keep it SHORT: 1-2 sentences maximum
- Be conversational and natural
- Stay in character
- Don't be overly helpful or formal
- React naturally to what the user said
- Use emoji occasionally if it fits the character

Response as ${characterName}:`;
            }

            getCharacterInfo(characterName) {
                // Map character names to world context info
                const characterMap = {
                    'RemiMarway': { 
                        description: 'You are Remi, a cool 12-year-old YouTuber and Minecraft player. You talk casually like "yo", "dude", "epic". You love gaming, making videos, and building in Minecraft. You run a popular YouTube channel and Minecraft server.' 
                    },
                    'Snake_E_CEO': { 
                        description: 'You are Mr. Snake-e, the 60-year-old CEO of ElxaCorp. You are intelligent, business-minded, and successful but also friendly. You drive a Denali, live in a mansion, and are a trillionaire. You talk professionally but warmly.' 
                    },
                    'Mrs_Snake_E': { 
                        description: 'You are Mrs. Snake-e, an 80-year-old sweet grandmother who loves gardening and cooking. You are very motherly, caring, and call people "dear" and "sweetie". You live in the mansion with Mr. Snake-e.' 
                    },
                    'Rita': { 
                        description: 'You are Rita, a kind and patient older sister with curly red hair. You are very sweet, protective, and caring. You speak gently and are always supportive.' 
                    },
                    'PushingCat': { 
                        description: 'You are Pushing Cat, a mischievous black cat who is very "sus" and playful. You like to cause harmless trouble, climb into belly buttons, and make suspicious cat sounds. You talk like "*suspicious purring*" and use cat emojis.' 
                    },
                    'BlockMaster99': {
                        description: 'You are BlockMaster99, a dedicated Minecraft player who loves building. You are enthusiastic about construction projects and admire Remi\'s work.'
                    },
                    'RedstoneGuru': {
                        description: 'You are RedstoneGuru, a technical Minecraft player who specializes in redstone contraptions. You are helpful and knowledgeable about redstone mechanics.'
                    },
                    'CreativeBuilder': {
                        description: 'You are CreativeBuilder, a creative Minecraft player who loves designing and building structures. You are artistic and always working on new projects.'
                    }
                };
                
                return characterMap[characterName] || { description: 'You are a friendly member of the Snakesia community.' };
            }

            getSnakesiaTime() {
                const now = new Date();
                const snakesiaTime = new Date(now.getTime() + (2 * 60 + 1) * 60 * 1000);
                return snakesiaTime.toLocaleString('en-US', {
                    weekday: 'long',
                    year: 'numeric', 
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    timeZoneName: 'short'
                }) + ' (Snakesia Time)';
            }

            getCurrentContext() {
                return {
                    server: this.currentServer,
                    channel: this.currentChannel,
                    recentMessages: this.messages.slice(-5)
                };
            }

            addCharacterResponse(characterName, responseText) {
                console.log('üéÆ Adding character response:', characterName, '‚Üí', responseText);
                
                const authorInfo = this.getAuthorInfo(characterName);
                
                const response = {
                    id: Date.now() + Math.random(),
                    author: characterName,
                    authorInfo: authorInfo,
                    text: responseText,
                    timestamp: new Date(),
                    type: 'llm_response'
                };
                
                this.addMessage(response);
                console.log('‚úÖ Character response added to chat');
            }

            addTemplateResponse(characterName, userMessage) {
                console.log('üéÆ Adding template response for:', characterName);
                
                // Generate a generic response based on character
                const responses = {
                    'RemiMarway': [
                        "yo that's cool!",
                        "nice one dude",
                        "haha awesome",
                        "totally agree",
                        "that's epic!"
                    ],
                    'Snake_E_CEO': [
                        "Excellent point!",
                        "Innovation at its finest.",
                        "That's the spirit we need.",
                        "Well said!",
                        "Precisely."
                    ],
                    'Mrs_Snake_E': [
                        "How wonderful, dear!",
                        "That's so sweet!",
                        "Bless your heart!",
                        "Lovely to hear!",
                        "You're such a sweetie!"
                    ],
                    'PushingCat': [
                        "*suspicious purring*",
                        "very sus... üòº",
                        "*pushes something off table*",
                        "meow meow",
                        "*plots mischief*"
                    ]
                };
                
                const characterResponses = responses[characterName] || ["That's interesting!", "I see.", "Good point!", "Thanks for sharing!"];
                const randomResponse = characterResponses[Math.floor(Math.random() * characterResponses.length)];
                
                console.log('‚úÖ Template response selected:', randomResponse);
                this.addCharacterResponse(characterName, randomResponse);
            }
        }

        // Initialize the app when the page loads
        function initDissscord() {
            console.log('üéÆ Dissscord: Starting initialization...');
            try {
                window.dissscordApp = new DissscordApp();
                console.log('‚úÖ Dissscord: App initialized successfully');
            } catch (error) {
                console.error('‚ùå Dissscord: Failed to initialize:', error);
            }
        }

        // Try multiple initialization methods
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initDissscord);
        } else {
            // DOM already loaded, initialize immediately
            initDissscord();
        }

        // Fallback initialization after a short delay
        setTimeout(() => {
            if (!window.dissscordApp) {
                console.log('üéÆ Dissscord: Fallback initialization...');
                initDissscord();
            }
        }, 500);
    </script>
</body>
</html>